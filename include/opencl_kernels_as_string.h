"\n"
"#ifdef _USE_FLOAT\n"
"#define FPTYPE float\n"
"#define ZERO    0.0f\n"
"#define HALF    0.5f\n"
"#define ONE     1.0f\n"
"#define SIX     6.0f\n"
"#define TWELVE 12.0f\n"
"#else\n"
"#pragma OPENCL EXTENSION cl_khr_fp64: enable\n"
"#define FPTYPE double\n"
"#define ZERO    0.0\n"
"#define HALF    0.5\n"
"#define ONE     1.0\n"
"#define SIX     6.0\n"
"#define TWELVE 12.0\n"
"#endif\n"
"\n"
"__kernel void opencl_azzero(  __global FPTYPE * a, __global FPTYPE * b, __global FPTYPE * c, const int natoms ) {\n"
"	 \n"
"  int nths = get_global_size( 0 );\n"
"  int id_th = get_global_id( 0 );\n"
"  int loc_id = id_th;\n"
"    \n"
"  while( loc_id < natoms ) {\n"
"\n"
"     a[ loc_id ] = ZERO;\n"
"     b[ loc_id ] = ZERO;\n"
"     c[ loc_id ] = ZERO;	\n"
"\n"
"     loc_id += nths;\n"
"  }\n"
"\n"
"} 	 \n"
"\n"
"__kernel void opencl_ekin(  __global FPTYPE * vx, __global FPTYPE * vy, __global FPTYPE * vz, const int natoms, __global FPTYPE * ekin ) {\n"
"\n"
"  int nths = get_global_size( 0 );\n"
"  int id_th = get_global_id( 0 );\n"
"  int loc_id = id_th;\n"
"\n"
"  ekin[id_th] = ZERO;\n"
"    \n"
"  while( loc_id < natoms ) {\n"
"\n"
"    ekin[id_th] += vx[loc_id] * vx[loc_id] + vy[loc_id] * vy[loc_id] + vz[loc_id] * vz[loc_id];\n"
"\n"
"    loc_id += nths;\n"
"  }\n"
"  //    sys->ekin *= 0.5*mvsq2e*sys->mass;\n"
"  //    sys->temp  = 2.0*sys->ekin/(3.0*sys->natoms-3.0)/kboltz;\n"
"}\n"
"\n"
"\n"
"inline FPTYPE pbc(FPTYPE x, const FPTYPE boxby2, const FPTYPE box)\n"
"{\n"
"    while (x >  boxby2) x -= box;\n"
"    while (x < -boxby2) x += box;\n"
"    return x;\n"
"}\n"
"\n"
"\n"
"__kernel void opencl_force( __global FPTYPE * fx, __global FPTYPE * fy, __global FPTYPE * fz, __global FPTYPE * rx, __global FPTYPE * ry, __global FPTYPE * rz, const int natoms, __global FPTYPE * epot, const FPTYPE c12, const FPTYPE c6, const FPTYPE rcsq, const FPTYPE boxby2, const FPTYPE box ){\n"
"\n"
"  int nths = get_global_size( 0 );\n"
"  int id_th = get_global_id( 0 );\n"
"  int loc_id = id_th;\n"
"\n"
"  /* zero energy and forces */\n"
"  epot[id_th] = ZERO;\n"
"\n"
"  while( loc_id < natoms ){\n"
"\n"
"    fx[ loc_id ] = ZERO;\n"
"    fy[ loc_id ] = ZERO;\n"
"    fz[ loc_id ] = ZERO;\n"
"    loc_id += nths;\n"
"  }\n"
"  \n"
"  loc_id = id_th;\n"
"  while( loc_id < natoms ) {\n"
"\n"
"    int j;\n"
"    FPTYPE rx1, ry1, rz1;\n"
"    rx1 = rx[loc_id];\n"
"    ry1 = ry[loc_id];\n"
"    rz1 = rz[loc_id];\n"
"    \n"
"    for( j = 0; j < natoms; ++j ) {\n"
"\n"
"      FPTYPE loc_rx, loc_ry, loc_rz, rsq;\n"
"      \n"
"      /* particles have no interactions with themselves */\n"
"      if ( loc_id == j) continue;\n"
"      \n"
"      /* get distance between particle i and j */\n"
"      loc_rx = pbc(rx1 - rx[j], boxby2, box);\n"
"      loc_ry = pbc(ry1 - ry[j], boxby2, box);\n"
"      loc_rz = pbc(rz1 - rz[j], boxby2, box);\n"
"      rsq = loc_rx * loc_rx + loc_ry * loc_ry + loc_rz * loc_rz;\n"
"      \n"
"      /* compute force and energy if within cutoff */\n"
"      if (rsq < rcsq) {\n"
"  	FPTYPE r6, rinv, ffac;\n"
"	\n"
"  	rinv = ONE / rsq;\n"
"  	r6 = rinv * rinv * rinv;\n"
"        \n"
"  	ffac = ( TWELVE * c12 * r6 - SIX * c6 ) * r6 * rinv;\n"
"  	epot[id_th] += HALF * r6 * ( c12 * r6 - c6 );\n"
"	\n"
"  	fx[loc_id] += loc_rx * ffac;\n"
"  	fy[loc_id] += loc_ry * ffac;\n"
"  	fz[loc_id] += loc_rz * ffac;\n"
"      }\n"
"    }\n"
"\n"
"    loc_id += nths;\n"
"  }\n"
"\n"
"}\n"
"\n"
"\n"
"__kernel void opencl_verlet_first( __global FPTYPE * fx, __global FPTYPE * fy, __global FPTYPE * fz, __global FPTYPE * rx, __global FPTYPE * ry, __global FPTYPE * rz, __global FPTYPE * vx, __global FPTYPE * vy, __global FPTYPE * vz, const int natoms, const FPTYPE dt, const FPTYPE dtmf) {\n"
"\n"
"  int nths = get_global_size( 0 );\n"
"  int id_th = get_global_id( 0 );\n"
"  int loc_id = id_th;\n"
"\n"
"  /* first part: propagate velocities by half and positions by full step */\n"
"  while( loc_id < natoms ){\n"
"  \n"
"    vx[loc_id] += dtmf * fx[loc_id];\n"
"    vy[loc_id] += dtmf * fy[loc_id];\n"
"    vz[loc_id] += dtmf * fz[loc_id];\n"
"    rx[loc_id] += dt*vx[loc_id];\n"
"    ry[loc_id] += dt*vy[loc_id];\n"
"    rz[loc_id] += dt*vz[loc_id];\n"
"  \n"
"    loc_id += nths;\n"
"  }\n"
"}\n"
"\n"
"\n"
"__kernel void opencl_verlet_second( __global FPTYPE * fx, __global FPTYPE * fy, __global FPTYPE * fz, __global FPTYPE * vx, __global FPTYPE * vy, __global FPTYPE * vz, const int natoms, const FPTYPE dt, const FPTYPE dtmf) {\n"
"\n"
"  int nths = get_global_size( 0 );\n"
"  int id_th = get_global_id( 0 );\n"
"  int loc_id = id_th;\n"
"\n"
"  /* second part: propagate velocities by another half step */\n"
"  while( loc_id < natoms ){\n"
"\n"
"    vx[loc_id] += dtmf * fx[loc_id];\n"
"    vy[loc_id] += dtmf * fy[loc_id];\n"
"    vz[loc_id] += dtmf * fz[loc_id];\n"
"    \n"
"    loc_id += nths;\n"
"  }\n"
"}\n"
"\n"
"\n"
